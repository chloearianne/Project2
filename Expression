//I MADE CONSTRUCTOR WORK AND I WROTE WORKING EQUALS AND TOSTRING METHODS, EXCEPT IT DOESN'T HANDLE TILDES -Terry

public class Expression2 {
	
	public ExprNode myRoot;
	public String expression;

	public Expression2(){// throws IllegalLineException{
		myRoot = null;
		expression = "";
	}
	
	public Expression2(String s){// throws IllegalLineException {
		if(isLegal(s)){
			expression = s;
			myRoot = new ExprNode(s);
		}
	}
	
	
	public boolean isLegal(String s){
		return true;
	}
	
	public static boolean equals(ExprNode node1, ExprNode node2){
		if(!node1.myItem.equals(node2)){
			return false;
		}
		if(!node1.myLeft.equals(node2.myLeft)){
			return false;
		}
		if(!node1.myRight.equals(node2.myRight)){
			return false;
		}
		return true;
	}
	
	
	
	public String toString() {
		return expression;
	}	
	
	
	
	private static class ExprNode{ //subclass
		private String myItem;
		private ExprNode myLeft;
		private ExprNode myRight;
		
		public ExprNode(){
			myItem = null;
			myLeft = null;
			myRight = null;
		}
		
		public ExprNode(String s){
			if(s.length()==0){
				myItem = "";
			}
			if(s.length()==1){
				myItem = s;
			}
			if (s.length() > 1) {
				myItem = findSymbol(s);
				myLeft = new ExprNode(findLeft(s)); //this keeps on calling without knowing if it should be called or not.
				myRight = new ExprNode(findRight(s));
			}
		}
		
		public ExprNode(String s, ExprNode left, ExprNode right){
			myItem =s;
			myLeft = left;
			myRight = right;
		}
		
		public String findSymbol(String s){
			if(s.length()==0){
				return "";
			}
			if(s.length()==1){
				return s;
			}
			int parenCounter = 0;
			for(int i = 1; i<s.length()-1; i++){
				if(s.charAt(i) == '('){
					parenCounter++;
				}
				if(s.charAt(i) == ')'){
					parenCounter--;
				}
				if(parenCounter == 0){
					if((""+s.charAt(i)+s.charAt(i+1)).equals("=>")){
						return ""+s.charAt(i)+s.charAt(i+1);
					}
					if (s.charAt(i) == '&') {
						return ""+s.charAt(i);
					}
					if (s.charAt(i) == '|') {
						return ""+s.charAt(i);
					}
				}
			}
			return "";
		}
		
		public String findLeft(String s){
			if(s.length()==0){
				return "";
			}
			if(s.length()==1){
				return s;
			}
			int parenCounter = 0;
			for(int i = 1; i<s.length()-1; i++){
				
				if(s.charAt(i) == '('){
					parenCounter++;
				}
				if(s.charAt(i) == ')'){
					parenCounter--;
				}
				if(parenCounter == 0){
					if((""+s.charAt(i)+s.charAt(i+1)).equals("=>")){
						return s.substring(1, i);
					}
					if (s.charAt(i) == '&') {
						return s.substring(1, i);
					}
					if (s.charAt(i) == '|') {
						return s.substring(1, i);
					}
				}
			}
			return "";
		}
		
		public String findRight(String s){
			if(s.length()==0){
				return "";
			}
			if(s.length()==1){
				return s;
			}
			int parenCounter = 0;
			for(int i = 1; i<s.length(); i++){
				if(s.charAt(i) == '('){
					parenCounter++;
				}
				if(s.charAt(i) == ')'){
					parenCounter--;
				}
				if(parenCounter == 0){
					if((""+s.charAt(i)+s.charAt(i+1)).equals("=>")){
						return s.substring(i+2, s.length()-1);
					}
					if (s.charAt(i) == '&') {
						return s.substring(i+1, s.length()-1);
					}
					if (s.charAt(i) == '|') {
						return s.substring(i+1, s.length()-1);
					}
				}
			}
			return "";
		}
		
		private boolean equals(ExprNode node){
			if (!myItem.equals(node.myItem)) {
				return false;
			}
			if (myLeft == null && node.myLeft != null) {
				return false;
			}
			if (myLeft != null && node.myLeft == null) {
				return false;
			}
			if (myRight == null && node.myRight != null) {
				return false;
			}
			if (myRight != null && node.myRight == null) {
				return false;
			}
			if (myLeft != null && node.myLeft != null) {
				if (!myLeft.equals(node.myLeft)) {
					return false;
				}
			}
			if (myRight != null && node.myRight != null) {
				if (!myRight.equals(node.myRight)) {
					return false;
				}
			}
			return true;
		}
		
		public String toString() {
			String rtn = "(";
			if (myLeft != null) {
				rtn = rtn + myLeft.toStringHelper();
			}
			rtn = rtn + myItem; 
			if (myRight != null) {
				rtn = rtn + myRight.toStringHelper();
			}
			rtn = rtn + ")";
			return rtn;
		}
		
		public String toStringHelper() {
			if (myLeft == null && myRight == null) {
				return myItem;
			}
			String rtn = "(";
			if (myLeft != null) {
				rtn = rtn + myLeft.toStringHelper();
			}
			rtn = rtn + myItem; 
			if (myRight != null) {
				rtn = rtn + myRight.toStringHelper();
			}
			rtn = rtn + ")";
			return rtn;
		}
		
	}
	
	public static void main(String[] args){
		String b ="((x&y)=>z)";
		String c ="((a=>b)=>c)";
		Expression2 none = new Expression2();
		Expression2 aa = new Expression2("(a=>b)");
		System.out.println(aa.myRoot.myItem);
		System.out.println(aa.myRoot.myLeft.myItem);
		System.out.println(aa.myRoot.myRight.myItem);
		System.out.println(none.equals(aa));
		Expression2 tt = new Expression2(b);
		System.out.println(tt.myRoot.myItem);
		System.out.println(tt.myRoot.myLeft.myItem);
		System.out.println(tt.myRoot.myLeft.myLeft.myItem);
		System.out.println(tt.myRoot.myLeft.myRight.myItem);
		System.out.println(tt.myRoot.myRight.myItem);
		Expression2 cc = new Expression2(c);
		System.out.println(aa.myRoot.equals(cc.myRoot.myLeft));
		
		Expression2 testExp1 = new Expression2("((a=>(b|c))=>((d&e)|f))");
		Expression2 testExp2 = new Expression2("(((a=>(b|c))=>((d&e)|f))=>z)");
		System.out.println(testExp1.myRoot.equals(testExp2.myRoot));
		System.out.println(testExp1.myRoot.equals(testExp2.myRoot.myLeft));
		System.out.println(testExp2.toString());
	}
	
	
	

}
