//SHOULD WORK BEAUTIFULLY EXCEPT FOR TILDE CASES

public class Expression2 {
	
	public ExprNode myRoot;
	public String expression;

	public Expression2(){// throws IllegalLineException{
		myRoot = null;
		expression = "";
	}
	
	public Expression2(String s){// throws IllegalLineException {
		if(isLegal(s)){
			expression = s;
			myRoot = new ExprNode(s);
		}
	}
	
	
	public boolean isLegal(String s){
		return true;
	}
	
	public static boolean equals(ExprNode node1, ExprNode node2){
		if(!node1.myItem.equals(node2)){
			return false;
		}
		if(!node1.myLeft.equals(node2.myLeft)){
			return false;
		}
		if(!node1.myRight.equals(node2.myRight)){
			return false;
		}
		return true;
	}
	
	
	
	public String toString() {
		return expression;
	}	
	
	
	
	private static class ExprNode{ //subclass
		private String myItem;
		private ExprNode myLeft;
		private ExprNode myRight;
		
		public ExprNode(){
			myItem = null;
			myLeft = null;
			myRight = null;
		}
		
		public ExprNode(String s){
			if(s.length()==0){
				myItem = "";
			}
			if(s.length()==1){
				myItem = s;
			}
			if (s.length() > 1) {
				myItem = findSymbol(s);
				myLeft = new ExprNode(findLeft(s)); //this keeps on calling without knowing if it should be called or not.
				myRight = new ExprNode(findRight(s));
			}
		}
		
		public ExprNode(String s, ExprNode left, ExprNode right){
			myItem =s;
			myLeft = left;
			myRight = right;
		}
		
		public String findSymbol(String s){
			if(s.length()==0){
				return "";
			}
			if(s.length()==1){
				return s;
			}
			int parenCounter = 0;
			for(int i = 1; i<s.length()-1; i++){
				if(s.charAt(i) == '('){
					parenCounter++;
				}
				if(s.charAt(i) == ')'){
					parenCounter--;
				}
				if(parenCounter == 0){
					if((""+s.charAt(i)+s.charAt(i+1)).equals("=>")){
						return ""+s.charAt(i)+s.charAt(i+1);
					}
					if (s.charAt(i) == '&') {
						return ""+s.charAt(i);
					}
					if (s.charAt(i) == '|') {
						return ""+s.charAt(i);
					}
				}
			}
			return "";
		}
		
		public String findLeft(String s){
			if(s.length()==0){
				return "";
			}
			if(s.length()==1){
				return s;
			}
			int parenCounter = 0;
			for(int i = 1; i<s.length()-1; i++){
				
				if(s.charAt(i) == '('){
					parenCounter++;
				}
				if(s.charAt(i) == ')'){
					parenCounter--;
				}
				if(parenCounter == 0){
					if((""+s.charAt(i)+s.charAt(i+1)).equals("=>")){
						return s.substring(1, i);
					}
					if (s.charAt(i) == '&') {
						return s.substring(1, i);
					}
					if (s.charAt(i) == '|') {
						return s.substring(1, i);
					}
				}
			}
			return "";
		}
		
		public String findRight(String s){
			if(s.length()==0){
				return "";
			}
			if(s.length()==1){
				return s;
			}
			int parenCounter = 0;
			for(int i = 1; i<s.length(); i++){
				if(s.charAt(i) == '('){
					parenCounter++;
				}
				if(s.charAt(i) == ')'){
					parenCounter--;
				}
				if(parenCounter == 0){
					if((""+s.charAt(i)+s.charAt(i+1)).equals("=>")){
						return s.substring(i+2, s.length()-1);
					}
					if (s.charAt(i) == '&') {
						return s.substring(i+1, s.length()-1);
					}
					if (s.charAt(i) == '|') {
						return s.substring(i+1, s.length()-1);
					}
				}
			}
			return "";
		}
		
		private boolean equals(ExprNode node){
			return true;
		}
		
	}
	
	public static void main(String[] args){
		String b ="((a&b)=>c)";
		Expression2 none = new Expression2();
		Expression2 aa = new Expression2("(a=>b)");
		System.out.println(aa.myRoot.myItem);
		System.out.println(aa.myRoot.myLeft.myItem);
		System.out.println(aa.myRoot.myRight.myItem);
		System.out.println(none.equals(aa));
		Expression2 tt = new Expression2(b);
		System.out.println(tt.myRoot.myItem);
		System.out.println(tt.myRoot.myLeft.myItem);
		System.out.println(tt.myRoot.myLeft.myLeft.myItem);
		System.out.println(tt.myRoot.myLeft.myRight.myItem);
		System.out.println(tt.myRoot.myRight.myItem);
	}
	
	
	

}
