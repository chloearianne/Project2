import java.util.*;

/*
	calls to mp, mt, repeat, ect. must take in strings and use try catches to see if they're valid
	must also extend the proof inside mp/mt, because if an exception isn't thrown then the reason is true
*/


public class Proof2 {
	private TheoremSet theorems;
	private String prevReason;
	private SubProof originalProof;
	private SubProof currentProof;
	private String previousReason;
	private ArrayList<SubProof> isProvenGlobal;
	private LineNumber currentLineNum;
	private TheoremSet myTheorems;
	private Hashtable<String, LineNumber> myLineNums;

	// Construct a proof by setting up the original (root) proof.
	public Proof2 (TheoremSet theorems) {
		originalProof = null;
		currentProof = originalProof;
		isProvenGlobal = new ArrayList<SubProof>();
		myTheorems = theorems;
		previousReason = "";
		currentLineNum = null;
		myLineNums = new Hashtable<String, LineNumber>();
	}

	public String nextLineNumber ( ) {
		//currentLine = new LineNumber(nextLine)
		return "";
	}
	
	//need to break this up into smaller methods
	//limit per method is 100 lines
	//fuuuuck
	
	private static String[] validReasons = {"print","show","repeat","ic","co","mt","mp"};


	public void extendProof (String x) throws IllegalLineException, IllegalInferenceException {
		if (x == null){
			throw new IllegalLineException("Cannot input a null value");
		}
		Scanner expScanner = new Scanner(x);
		if(!expScanner.hasNext()){
			throw new IllegalLineException("Cannot input an empty string");
		}	
		
		ArrayList<String> myWords = new ArrayList<String>();
		while(expScanner.hasNext()){							//separate the arguments of the string
			myWords.add(expScanner.next());
		}
		
		//general try catch statement to handle exceptions when calling outside helper methods
		//ie. if calls to assume, repeat, mt, mc, ect. throw an exception
		try{		
			String reason = myWords.get(0);			
			if(myWords.size() == 1){				//only print statements can stand alone
				if (reason.equals("print")){
					System.out.println(this);
					return;
				} else{
					throw new IllegalLineException("A reason should be followed by at least an expression");
				}
			} else if(myWords.size() == 2){			//must be a length 2 to be a valid use of show, assume, or theorem
				if (reason.equals("show")){			//ie. only one expression follows the reason
					show(myWords.get(1));
				} else if (reason.equals("assume")){				//handles assume
					if (!prevReason.equals("show")){
						throw new IllegalLineException("An assume can only follow a show");
					} else{
						assume(myWords.get(1));
					}
				} else if (theorems.hasTheorem(reason)){			//handles theorem use
					theorem(reason, myWords.get(1));
				} else{
					throw new IllegalLineException(reason + " is not a valid theorem or has an incorrect number of arguments");
				}
			} else if (myWords.size() == 3){
				if (reason.equals("repeat")){					//handles repeat, if repeat errors, pass it on
					repeat(myWords.get(1), myWords.get(2));
				}
				else if (reason.equals("ic")){					//handles ic
					ic(myWords.get(1), myWords.get(2));
				} else{
					throw new IllegalLineException("Only repeat and ic take in 2 arguments");
				}			
			} else if(myWords.size() == 4){
				if (reason.equals("mp")){
					mp(myWords.get(1), myWords.get(2), myWords.get(3));
				}
				else if (reason.equals("mt")){
					mt(myWords.get(1), myWords.get(2), myWords.get(3));
				}
				else if (reason.equals("co")){
					co(myWords.get(1), myWords.get(2), myWords.get(3));
				} else{
					throw new IllegalLineException(reason + " does not take in 3 arguments");
				}
			} else {
				throw new IllegalLineException("There can never be more than 3 arguments for a reason");
			}
			//if it hasn't thrown an exception, then the reason has been validly used
			prevReason = reason;
		} catch (IllegalLineException e){
			throw e;
		} catch (IllegalInferenceException e){
			throw e;
		}
	}
	
	private void show(String exp) throws IllegalInferenceException, IllegalLineException{
		Expression expression = null;
		try{
			expression = new Expression(exp);
		} catch (IllegalLineException e){
			throw e;
		}
		
		if (originalProof == null){
			originalProof = new SubProof(expression, null, currentLineNum);
			currentProof = originalProof;
		} else{
			SubProof child = new SubProof(expression, currentProof, currentLineNum);
			currentProof.addChildProof(child);
		}
	}
	
	private void theorem(String thm, String exp) throws IllegalInferenceException, IllegalLineException{
		Expression expression = null;
		try{
			expression = new Expression(exp);
		} catch (IllegalLineException e){
			throw e;
		}
		if (theorems.validTheorem(thm, expression)){
			currentProof.assumptions.put(currentLineNum, expression);
		} else{
			throw new IllegalInferenceException("Improper use of a theorem, variables used incorrectly");
		}
	}
	
	private void repeat(String lineNum, String exp) throws IllegalInferenceException, IllegalLineException{
		Expression expression = null;
		try{
			expression = new Expression(exp);
		} catch(IllegalLineException e){
			throw e;
		}
		LineNumber line = myLineNums.get(lineNum);
		if(line == null){
			throw new IllegalLineException(lineNum + " is not a valid line number");
		}
		
		if (currentProof.assumptions.contains(line) || isProvenGlobal.contains(line)){
			currentProof.assumptions.put(currentLineNum, expression);
		}
		
		throw new IllegalInferenceException("cannot access " + line + " in call to repeat");
	}
	
	public static String switchSign(String s) {
		if (s.substring(0,1).equals("~")) {
			return s.substring(1, s.length());
		} else {
			return "~" + s;
		}
	}

	public void assume(String exp) throws IllegalInferenceException {
		//fill in
	}

	public void mp(String line1, String line2, String rtnString) throws IllegalInferenceException, IllegalLineException {
		//fill
	}

	public void mt(String line1, String line2, String rtnString) throws IllegalInferenceException { //says String but it should say Expression
		//fill
	}

	public void co(String line1, String line2, String rtn) throws IllegalInferenceException {
		//fill
	}
	
	public void ic(String line1, String rtn) throws IllegalInferenceException {
		//fill
	}	
	
	
	public String toString () {
		if (!(originalProof == null)) {
			return toStringHelper(originalProof);
		}
		return "";
	}	
	
	public String toStringHelper(SubProof pf) {
		String toReturn = "";
		toReturn = toReturn + "/n" + pf.myLineNumber + " " + pf.reason + " " + pf.myExpression.toString();
		Iterator<SubProof> iter = pf.childProofs.iterator();
		while (iter.hasNext()) {
			toStringHelper(iter.next());
		}
		return toReturn;
	}
	
	public boolean isComplete ( ) {
		int sizeOfChildren = originalProof.childProofs.size();
		// If the last step of the proof has children, then that subproof is clearly not done and it's impossible
		// for the entire proof to be done.
		if (!(originalProof.childProofs.get(sizeOfChildren - 1).childProofs == null)) {
			return false;
		}
		// Convert originalProof expression (saved in firstExpr) to a string, and convert the most recent proof step 
		// to a string and save it in lastExpr. Compare these two to see if they're the same. If they are, the proof is done.
		SubProof toProve = originalProof.childProofs.get(0);
		Expression firstExpr = toProve.myExpression;
		String firstString = firstExpr.toString();
		
		SubProof lastProof = originalProof.childProofs.get(sizeOfChildren - 1);
		Expression lastExpr = lastProof.myExpression;
		String lastString = lastExpr.toString();
		return lastString.equals(firstString) && lastProof.myLineNumber.isProven;
		
	}
	
	// SubProof is a child class much like Amoeba was a child class of AmoebaFamily. Each proof object has a original proof
	// that is analogous to myRoot (stored in myExpression), and an ArrayList of childProofs that is analogous to myChildren.
	// Each proof also contains its own line number and a reference to its parent proof.
	public static class SubProof {

		//hashtable for states-- what is true for this particular proof, what's been assumed, proven 
		//change subproof to proof instead of line
		
		private Expression myExpression;
		private SubProof parentProof;
		private ArrayList<SubProof> childProofs;
		private LineNumber myLineNumber;
		private String reason;
		private Hashtable<LineNumber, Expression> assumptions;
		
		public SubProof(Expression expr, SubProof parent, LineNumber line) {
			parentProof = parent;
			childProofs = new ArrayList<SubProof>();
			myExpression = expr;
			myLineNumber = line;
			assumptions = new Hashtable<LineNumber, Expression>();
		}
		
		public boolean hasParent () {
			return !(this.parentProof == null);
		}
		
		public void addChildProof(SubProof child) {
			childProofs.add(child);
		}
		
		public LineNumber lineNumber () {
			return myLineNumber;
		}
		
		
	}
}
