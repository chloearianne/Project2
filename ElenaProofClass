import java.util.*;

public class Proof {
  private TheoremSet theorems;
	private boolean originalTheoremInit = false;
	private String prevReason;
	SubProof originalProof = null;
	SubProof currentProof;
	String previousReason;
	ArrayList<SubProof> isProvenGlobal;
	TheoremSet myTheorems;
	int step;

	// Construct a proof by setting up the original (root) proof.
	public Proof (TheoremSet theorems) {
		originalProof = new SubProof(null, null, new LineNumber(0));
		currentProof = originalProof;
		isProvenGlobal = new ArrayList<SubProof>();
		myTheorems = theorems;
		previousReason = "";
	}

	public LineNumber nextLineNumber ( ) {
		if (!(originalProof == null)) {
			LineNumber myLine = new LineNumber();
			return myLine;
		}
		return null;
	}
	
	public void extendProof (String x) throws IllegalLineException, IllegalInferenceException {
		if (x == null){
			throw new IllegalLineException("Cannot input a null value");
		}
		Scanner expScanner = new Scanner(x);
		if(!expScanner.hasNext()){
			throw new IllegalLineException("Cannot input an empty string");
		}	
		
		ArrayList<String> myWords = new ArrayList<String>();
		while(expScanner.hasNext()){							//separate the arguments of the string
			myWords.add(expScanner.next());
		}
		
		String reason = myWords.get(0);			//the reason should always be the first argument		
		if(myWords.size() == 1){				//only print statements can stand alone
			if (reason.equals("print")){
				System.out.println(this);
				return;
			} else{
				throw new IllegalLineException("A reason should be followed by at least an expression");
			}
		} else if(myWords.size() == 2){			//must be a length 2 to be a valid use of show, assume, or theorem
			if (reason.equals("show")){			//ie. only one expression follows the reason
				if (originalProof == null){
					originalProof = new SubProof(expression, null, new LineNumber(currentLine));
					currentProof = originalProof;
				} else{
					SubProof child = new SubProof(expression, currentProof, new LineNumber(currentLine));
					currentProof.addChildProof(child);
				}
			} else if (reason.equals("assume")){				//handles assume
				if (!prevReason.equals("show")){
					throw new IllegalLineException("An assume can only follow a show");
				} else{
					assume(myWords.get(1));
				}
			} else if (theorems.hasTheorem(reason)){			//handles theorem use
				if (theorems.validTheorem(reason, expression)){
					currentProof.assumptions.put(currentLine, expression);
				} else{
					throw new IllegalInferenceException("Improper use of a theorem, variables used incorrectly");
				}
			} else{
				throw new IllegalLineException(reason + " is not a valid theorem or has an incorrect number of arguments");
			}
		} else if (myWords.size() == 3){
			if (reason.equals("repeat")){					//handles repeat, if repeat errors, pass it on
				try{
					repeat(myWords.get(1), myWords.get(2));
				} catch (Exception e){
					throw e;
				} 
			}
			else if (reason.equals("ic")){					//handles ic
				try{
					ic(myWords.get(1), myWords.get(2));
				} catch (Exception e){
					throw e;
				} 
			} else{
				throw new IllegalLineException("Only repeat and ic take in 2 arguments");
			}			
		} else if(myWords.size() == 4){
			if (reason.equals("mp")){
				try{
					mp(myWords.get(1), myWords.get(2), myWords.get(3));
				} catch (Exception e){
					throw e;
				}
			}
			else if (reason.equals("mt")){
				try{
					mt(myWords.get(1), myWords.get(2), myWords.get(3));
				} catch (Exception e){
					throw e;
				}	
			}
			else if (reason.equals("co")){
				try{
					co(myWords.get(1), myWords.get(2), myWords.get(3));
				} catch (Exception e){
					throw e;
				}
			} else{
				throw new IllegalLineException(reason + " does not take in 3 arguments");
			}
		} else {
			throw new IllegalLineException("There can never be more than 3 arguments for a reason");
		}
		//if it hasn't thrown an exception, then the reason has been validly used
		prevReason = reason;
	}
	
	public String toString ( ) {
		if (!(originalProof == null)) {
			return toStringHelper(originalProof);
		}
		return "";
	}	
	
	public String toStringHelper(SubProof pf) {
		String toReturn = "";
		toReturn = toReturn + "/n" + pf.myLineNumber + " " + pf.reason + " " + pf.myExpression.toString();
		Iterator<SubProof> iter = pf.childProofs.iterator();
		while (iter.hasNext()) {
			toStringHelper(iter.next());
		}
		return toReturn;
	}
	
	public boolean isComplete ( ) {
		int sizeOfChildren = originalProof.childProofs.size();
		// If the last step of the proof has children, then that subproof is clearly not done and it's impossible
		// for the entire proof to be done.
		if (!(originalProof.childProofs.get(sizeOfChildren - 1).childProofs == null)) {
			return false;
		}
		// Convert originalProof expression (saved in firstExpr) to a string, and convert the most recent proof step 
		// to a string and save it in lastExpr. Compare these two to see if they're the same. If they are, the proof is done.
		SubProof toProve = originalProof.childProofs.get(0);
		Expression firstExpr = toProve.myExpression;
		String firstString = firstExpr.toString();
		
		SubProof lastProof = originalProof.childProofs.get(sizeOfChildren - 1);
		Expression lastExpr = lastProof.myExpression;
		String lastString = lastExpr.toString();
		return lastString.equals(firstString) && lastProof.myLineNumber.isProven;
		
	}
	
	// SubProof is a child class much like Amoeba was a child class of AmoebaFamily. Each proof object has a original proof
	// that is analogous to myRoot (stored in myExpression), and an ArrayList of childProofs that is analogous to myChildren.
	// Each proof also contains its own line number and a reference to its parent proof.
	public static class SubProof {

		//hashtable for states-- what is true for this particular proof, what's been assumed, proven 
		//change subproof to proof instead of line
		
		private Expression myExpression;
		private SubProof parentProof;
		private ArrayList<SubProof> childProofs;
		private LineNumber myLineNumber;
		private String reason;
		private Hashtable<LineNumber, Expression> assumptions;
		
		public SubProof(Expression expr, SubProof parent, LineNumber line) {
			parentProof = parent;
			childProofs = new ArrayList<SubProof>();
			myExpression = expr;
			myLineNumber = line;
			assumptions = new Hashtable<LineNumber, Expression>();
		}
		
		public boolean hasParent () {
			return !(this.parentProof == null);
		}
		
		public void addChildProof(SubProof child) {
			childProofs.add(child);
		}
		
		public LineNumber lineNumber () {
			return myLineNumber;
		}
		
		
	}
}
